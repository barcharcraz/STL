// format standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _FORMAT_
#define _FORMAT_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#if !_HAS_CXX20
#pragma message("The contents of <format> are available only with C++20 or later.")
#else // ^^^ !_HAS_CXX20 / _HAS_CXX20 vvv

#include <locale>
#include <string_view>
#include <variant>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN


class format_error : public std::runtime_error {};

template <class _CharT>
class basic_format_parse_context {
public:
    using char_type      = _CharT;
    using const_iterator = typename basic_string_view<_CharT>::const_iterator;

public:
    constexpr explicit basic_format_parse_context(basic_string_view<_CharT> _Fmt, size_t _Num_args = 0) noexcept;
    basic_format_parse_context(const basic_format_parse_context&) = delete;
    basic_format_parse_context& operator=(const basic_format_parse_context&) = delete;

    constexpr const_iterator begin() const noexcept;
    constexpr const_iterator end() const noexcept;
    constexpr void advance_to(const_iterator _It);

    constexpr size_t next_arg_id();
    constexpr void check_arg_id(size_t _Id);
};


template <class _CharT, class _Ty>
struct _Named_arg {
    const _CharT* _Name;
    const _Ty& _Val;
};

template <class>
constexpr bool _Is_named_arg_v = false;

template <class _Ty, class _CharT>
constexpr bool _Is_named_arg_v<_Named_arg<_CharT, _Ty>> = true;

template <class _Context>
class basic_format_arg {
public:
    class handle;

    basic_format_arg() noexcept;
    explicit operator bool() const noexcept;
};

template <class _Context, class... _Args>
class _Format_arg_store {
    static constexpr size_t _Num_args       = sizeof...(_Args);
    static constexpr size_t _Num_named_args = (... + _Is_named_arg_v<_Args>);

    // TODO: no arg packing yet

    using _Value_type = basic_format_arg<_Context>;
};

template <class _Context>
class basic_format_args {
public:
    basic_format_args() noexcept;
    template <class... _Args>
    basic_format_args(const _Format_arg_store<_Context, _Args...>& store) noexcept;

    basic_format_arg<_Context> get(size_t _Index) const noexcept;
};

template <class _Out, class _CharT>
class basic_format_context {
public:
    using iterator  = _Out;
    using char_type = _CharT;
    template <class _Ty>
    // using formatter_type = formatter<_Ty, _CharT>;
    basic_format_arg<basic_format_context> arg(size_t _Id) const;
    _STD locale locale();

    iterator out();
    void advance_to(iterator _It);
};

template <typename _Context>
struct _Custom_value {
    const void* _Value;
    void (*_Format)(const void*, basic_format_parse_context<_Context::char_type>&, _Context&);
};
template <typename _Context>
using _Format_arg_value = _STD variant<int, unsigned, long long, unsigned long long, bool, _Context::char_type, float,
    double, const void*, _STD basic_string_view<_Context::char_type>, _Custom_value<_Context>>;

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _HAS_CXX20
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _FORMAT_
