// format standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _FORMAT_
#define _FORMAT_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#if !_HAS_CXX20
#pragma message("The contents of <format> are available only with C++20 or later.")
#else // ^^^ !_HAS_CXX20 / _HAS_CXX20 vvv

#include <cassert>
#include <concepts>
#include <exception>
#include <iterator>
#include <locale>
#include <string>
#include <string_view>
#include <variant>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN


class format_error : public _STD runtime_error {
    using _STD runtime_error::runtime_error;
};

enum class _Align { _None, _Left, _Right, _Center };

// clang-format off
template <typename _Ty, typename _CharT>
concept _Parse_callbacks = requires(_Ty _At, _STD basic_string_view<_CharT> _Sv, _Align _Aln) {
    { _At._On_align(_Aln) } -> same_as<void>;
    { _At._On_fill(_Sv) } -> same_as<void>;
};
//clang-format on

template <class _CharT, typename _Callbacks_type> requires _Parse_callbacks<_Callbacks_type, _CharT>
constexpr const _CharT* _Parse_align(const _CharT* _Begin, const _CharT* _End, _Callbacks_type&& _Callbacks) {
    // done with parsing, or reached the end of a replacement field.
    if (_Begin == _End || *_Begin == '}') {
        return _Begin;
    }

    // align and fill
    auto _Align    = _Align::_None;
    auto _Align_pt = _Begin + 1;
    if (_Align_pt == _End) {
        _Align_pt = _Begin;
    }
    if (_Begin == _End) {
        _Begin--;
    }
    for (;;) {
        switch (static_cast<char>(*_Align_pt)) {
        case '<':
            _Align = _Align::_Left;
            break;
        case '>':
            _Align = _Align::_Right;
            break;
        case '^':
            _Align = _Align::_Center;
            break;
        }
        if (_Align != _Align::_None) {
            if (_Align_pt != _Begin) {
                if (*_Begin == '{') {
                    throw format_error("invalid fill character '{'");
                }
                _Callbacks._On_fill({_Begin, static_cast<size_t>(_Align_pt - _Begin)});
                _Begin = _Align_pt + 1;
            } else {
                ++_Begin;
            }
            _Callbacks._On_align(_Align);
            break;
        } else if (_Align_pt == _Begin) {
            break;
        }
        _Align_pt = _Begin;
    }
    return _Begin;
}


template <class _CharT>
class basic_format_parse_context {
public:
    using char_type      = _CharT;
    using const_iterator = typename basic_string_view<_CharT>::const_iterator;

private:
    basic_string_view<_CharT> _Format_string;
    size_t _Num_args;
    // The standard says this is size_t, however we use ptrdiff_t to save some space
    // by not having to store the indexing mode. Below is a more detailed explination
    // of how this works.
    ptrdiff_t _Next_arg_id = 0;


public:
    constexpr explicit basic_format_parse_context(basic_string_view<_CharT> _Fmt, size_t _Num_args = 0) noexcept
        : _Format_string(_Fmt), _Num_args(_Num_args) {}
    basic_format_parse_context(const basic_format_parse_context&) = delete;
    basic_format_parse_context& operator=(const basic_format_parse_context&) = delete;

    constexpr const_iterator begin() const noexcept {
        return _Format_string.begin();
    }
    constexpr const_iterator end() const noexcept {
        return _Format_string.end();
    }
    constexpr void advance_to(const_iterator _It) {
        _Format_string.remove_prefix(_It - begin());
    }


    // While the standard presents an exposition only enum value for
    // the indexing mode (manual, automatic, or unknown) we use _Next_arg_id to indicate it.
    // _Next_arg_id == 0 means unknown
    // _Next_arg_id > 0 means automatic
    // _Next_arg_id == -1 means manual
    constexpr size_t next_arg_id() {
        if (_Next_arg_id >= 0) {
            return _Next_arg_id++;
        }
        throw _STD format_error("Can not switch from manual to automatic indexing");
    }
    constexpr void check_arg_id(size_t _Id) {
        (void)_Id;
        if (_Next_arg_id > 0) {
            throw _STD format_error("Can not switch from automatic to manual indexing");
        }
        _Next_arg_id = -1;
    }
};


template <class _CharT, class _Ty>
struct _Named_arg {
    const _CharT* _Name;
    const _Ty& _Val;
};

template <class>
constexpr bool _Is_named_arg_v = false;

template <class _Ty, class _CharT>
constexpr bool _Is_named_arg_v<_Named_arg<_CharT, _Ty>> = true;

template <typename _Context>
struct _Custom_value {
    const void* _Value;
    void (*_Format)(const void*, basic_format_parse_context<typename _Context::char_type>&, _Context&);
};
template <typename _Context>
using _Format_arg_value =
    _STD variant<monostate, int, unsigned, long long, unsigned long long, bool, typename _Context::char_type, float, double,
        const void*, _STD basic_string_view<typename _Context::char_type>, _Custom_value<_Context>>;

template <class _Context>
class basic_format_arg {
private:
    using _Char_type = typename _Context::char_type;
    _Format_arg_value<_Context> _Value;

public:
    class handle {
        const void* _Ptr;
        void (*_Format)(basic_format_parse_context<_Char_type>& _Parse_ctx, _Context _Format_ctx,
                        const void*);
        friend class basic_format_arg<_Context>;

    public:
        void format(basic_format_parse_context<_Char_type>& _Parse_ctx, _Context& _Format_ctx) {
            _Format(_Parse_ctx, _Format_ctx, _Ptr);
        }
    };

    basic_format_arg() noexcept = default;
    explicit operator bool() const noexcept {
        return !_STD holds_alternative<monostate>(_Value);
    }
};

template <class _Context, class... _Args>
class _Format_arg_store {
    static constexpr size_t _Num_args       = sizeof...(_Args);
    static constexpr size_t _Num_named_args = (... + _Is_named_arg_v<_Args>);

    // TODO: no arg packing yet

    using _Value_type = basic_format_arg<_Context>;
};

template <class _Context>
class basic_format_args {
public:
    basic_format_args() noexcept;
    template <class... _Args>
    basic_format_args(const _Format_arg_store<_Context, _Args...>& store) noexcept;

    basic_format_arg<_Context> get(size_t _Index) const noexcept;
};

template <class _Out, class _CharT>
class basic_format_context {
private:
    _Out _OutputIt;
    basic_format_args<basic_format_context> _Args;
    _STD locale _Loc;

public:
    using iterator  = _Out;
    using char_type = _CharT;
    template <class _Ty>
    // using formatter_type = formatter<_Ty, _CharT>;
    basic_format_arg<basic_format_context> arg(size_t _Id) const {
        return _Args.get(_Id);
    }
    _STD locale locale() {
        return _Loc;
    }

    iterator out() {
        return _OutputIt;
    }
    void advance_to(iterator _It) {
        // TODO: IDL support probably required
        _OutputIt = _It;
    }
};


// alias declerations
using format_context  = basic_format_context<back_insert_iterator<string>, string::value_type>;
using wformat_context = basic_format_context<back_insert_iterator<wstring>, wstring::value_type>;
using format_args     = basic_format_args<format_context>;
using wformat_args    = basic_format_args<wformat_context>;

// FUNCTION vformat
string vformat(string_view _Fmt, format_args _Args);
wstring vformat(wstring_view _Fmt, wformat_args _Args);
string vformat(const locale& _Loc, string_view _Fmt, format_args _Args);
wstring vformat(const locale& _Loc, wstring_view _Fmt, wformat_args _Args);


_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _HAS_CXX20
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _FORMAT_
