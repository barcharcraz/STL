// format standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _FORMAT_
#define _FORMAT_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#ifndef __cpp_lib_concepts
#pragma message("The contents of <format> are available only with C++20 concepts support.")
#else // ^^^ !defined(__cpp_lib_concepts) / defined(__cpp_lib_concepts) vvv

#include <charconv>
#include <concepts>
#include <exception>
#include <iterator>
#include <locale>
#include <string>
#include <string_view>
#include <variant>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN


class format_error : public runtime_error {
    using runtime_error::runtime_error;
};

enum class _Align { _None, _Left, _Right, _Center };

struct _Auto_id_tag {};

// clang-format off
template <class _Ty, class _CharT>
concept _Parse_spec_callbacks = requires(_Ty _At, basic_string_view<_CharT> _Sv, _Align _Aln) {
    { _At._On_align(_Aln) } -> same_as<void>;
    { _At._On_fill(_Sv) } -> same_as<void>;
    { _At._On_width(_STD declval<int>()) } -> same_as<void>;
    { _At._On_dynamic_width(_STD declval<int>()) } -> same_as<void>;
    { _At._On_dynamic_width( _STD declval<_Auto_id_tag>()) } -> same_as<void>;
};
template <class _Ty, class _CharT>
concept _Parse_arg_id_callbacks = requires(_Ty _At) {
    { _At._On_auto_id() } -> same_as<void>;
    { _At._On_manual_id(_STD declval<int>()) } -> same_as<void>;
};
// clang-format on

template <class _CharT>
const _CharT* _Parse_nonnegative_integer(const _CharT* _Begin, const _CharT* _End, int& _Integer) {
    auto [_Ptr, _Ec] = _STD from_chars(_Begin, _End, _Integer, 10);
    if (_Ec != _STD errc{}) {
        throw _STD format_error("Invalid integer");
    }
    if (_Integer < 0) {
        throw _STD format_error("Nonnegative integer is nonnonnegative");
    }
    return _Ptr;
}

template <class _CharT, _Parse_arg_id_callbacks<_CharT> _Callbacks_type>
constexpr void _Parse_arg_id(_STD basic_string_view<_CharT> _View, _Callbacks_type&& _Callbacks) {
    _STL_INTERNAL_CHECK(_Begin != _End);
    _CharT _Ch = _View.front();
    // No id provided, format string is using automatic indexing.
    if (_Ch == '}' || _Ch == ':') {
        _Callbacks._On_auto_id();
        return;
    }
    if (_Ch >= '0' && _Ch <= '9') {
        int _Index = 0;
        // arg_id is not allowed to have any leading zeros, but is allowed to be
        // equal to zero (but not '00'). So if _Ch is zero we skip the parsing, leave
        // _Index set to zero and let the validity checks below ensure that the arg_id
        // wasn't something like "00", or "023".
        if (_Ch != '0') {
            auto _New_Begin = _Parse_nonnegative_integer(_View.begin(), _View.end(), _Index);
            _View.remove_prefix(_New_Begin - _View.begin());
        } else {
            _View.remove_prefix(1);
        }
        // The format string shouldn't end right after the index number.
        // The only things permitted after the index are the end of the replacement field ('}')
        // or the beginning of the format spec (':').
        if (_View.empty() || (_View.front() != '}' && _View.front() != ':')) {
            throw _STD format_error("invalid format string");
        }
        _Callbacks._On_manual_id(_Index);
        return;
    }
    // This is where we would parse named arg ids if std::format were to support them.
    throw _STD format_error("Invalid format string.");
}

template <class _CharT, _Parse_spec_callbacks<_CharT> _Callbacks_type>
constexpr const _CharT* _Parse_align(const _CharT* _Begin, const _CharT* _End, _Callbacks_type&& _Callbacks) {
    // done with parsing, or reached the end of a replacement field.
    if (_Begin == _End || *_Begin == '}') {
        return _Begin;
    }

    // align and fill
    auto _Align    = _Align::_None;
    auto _Align_pt = _Begin + 1;
    if (_Align_pt == _End) {
        _Align_pt = _Begin;
    }
    if (_Begin == _End) {
        _Begin--;
    }
    for (;;) {
        switch (static_cast<char>(*_Align_pt)) {
        case '<':
            _Align = _Align::_Left;
            break;
        case '>':
            _Align = _Align::_Right;
            break;
        case '^':
            _Align = _Align::_Center;
            break;
        }
        if (_Align != _Align::_None) {
            if (_Align_pt != _Begin) {
                if (*_Begin == '{') {
                    throw format_error("invalid fill character '{'");
                }
                _Callbacks._On_fill({_Begin, static_cast<size_t>(_Align_pt - _Begin)});
                _Begin = _Align_pt + 1;
            } else {
                ++_Begin;
            }
            _Callbacks._On_align(_Align);
            break;
        } else if (_Align_pt == _Begin) {
            break;
        }
        _Align_pt = _Begin;
    }
    return _Begin;
}

// Adapts a type modeling _Parse_spec_callbacks to model _Parse_arg_id_callbacks.
// Used in _Parse_width so that _Parse_arg_id can be used to parse dynamic widths.
template <class _CharT, class _Callbacks_type>
requires _Parse_spec_callbacks<_Callbacks_type, _CharT> struct _Width_adapter {
    _Callbacks_type& _Callbacks;

    explicit constexpr _Width_adapter(_Callbacks_type& _Handler) : _Callbacks(_Handler) {}

    constexpr void _On_auto_id() {
        _Callbacks._On_dynamic_width(_Auto_id_tag{});
    }
    constexpr void _On_manual_id(int _Id) {
        _Callbacks._On_dynamic_width(_Id);
    }
};

template <class _CharT, class _Callbacks_type>
requires _Parse_spec_callbacks<_Callbacks_type, _CharT> constexpr const _CharT* _Parse_width(
    const _CharT* _Begin, const _CharT* _End, _Callbacks_type&& _Callbacks) {
    _STL_INTERNAL_CHECK(_Begin != _End);
    if ('0' <= *_Begin && *_Begin <= '9') {
        int _Value = 0;
        _Begin     = _Parse_nonnegative_integer(_Begin, _End, _Value);
        _Callbacks._On_width(_Value);
    } else if (*_Begin == '{') {
        ++_Begin;
        if (_Begin != _End) {
            _Begin = _Parse_arg_id(_STD basic_string_view<_CharT>(_Begin, _End - _Begin), _Width_adapter(_Callbacks));
        }
        if (_Begin == _End || *_Begin != '}') {
            throw _STD format_error("Invalid format string");
        }
        ++_Begin;
    }
    return _Begin;
}

template <class _CharT>
class basic_format_parse_context {
public:
    using char_type      = _CharT;
    using const_iterator = typename basic_string_view<_CharT>::const_iterator;

private:
    basic_string_view<_CharT> _Format_string;
    size_t _Num_args;
    // The standard says this is size_t, however we use ptrdiff_t to save some space
    // by not having to store the indexing mode. Below is a more detailed explanation
    // of how this works.
    ptrdiff_t _Next_arg_id = 0;


public:
    constexpr explicit basic_format_parse_context(basic_string_view<_CharT> _Fmt, size_t _Num_args = 0) noexcept
        : _Format_string(_Fmt), _Num_args(_Num_args) {}
    basic_format_parse_context(const basic_format_parse_context&) = delete;
    basic_format_parse_context& operator=(const basic_format_parse_context&) = delete;

    constexpr const_iterator begin() const noexcept {
        return _Format_string.begin();
    }
    constexpr const_iterator end() const noexcept {
        return _Format_string.end();
    }
    constexpr void advance_to(const_iterator _It) {
        _Format_string.remove_prefix(_It - begin());
    }


    // While the standard presents an exposition only enum value for
    // the indexing mode (manual, automatic, or unknown) we use _Next_arg_id to indicate it.
    // _Next_arg_id == 0 means unknown
    // _Next_arg_id > 0 means automatic
    // _Next_arg_id == -1 means manual
    constexpr size_t next_arg_id() {
        if (_Next_arg_id >= 0) {
            return _Next_arg_id++;
        }
        throw _STD format_error("Can not switch from manual to automatic indexing");
    }
    constexpr void check_arg_id(size_t _Id) {
        (void) _Id;
        if (_Next_arg_id > 0) {
            throw _STD format_error("Can not switch from automatic to manual indexing");
        }
        _Next_arg_id = -1;
    }
};


template <class _CharT, class _Ty>
struct _Named_arg {
    const _CharT* _Name;
    const _Ty& _Val;
};

template <class>
constexpr bool _Is_named_arg_v = false;

template <class _Ty, class _CharT>
constexpr bool _Is_named_arg_v<_Named_arg<_CharT, _Ty>> = true;

template <class _Context>
struct _Custom_value {
    const void* _Value;
    void (*_Format)(const void*, basic_format_parse_context<typename _Context::char_type>&, _Context&);
};
template <class _Context>
using _Format_arg_value =
    _STD variant<monostate, int, unsigned, long long, unsigned long long, bool, typename _Context::char_type, float,
        double, const void*, _STD basic_string_view<typename _Context::char_type>, _Custom_value<_Context>>;

template <class _Context>
class basic_format_arg {
private:
    using _Char_type = typename _Context::char_type;
    _Format_arg_value<_Context> _Value;

public:
    class handle {
        const void* _Ptr;
        void (*_Format)(basic_format_parse_context<_Char_type>& _Parse_ctx, _Context _Format_ctx, const void*);
        friend class basic_format_arg<_Context>;

    public:
        void format(basic_format_parse_context<_Char_type>& _Parse_ctx, _Context& _Format_ctx) {
            _Format(_Parse_ctx, _Format_ctx, _Ptr);
        }
    };

    basic_format_arg() noexcept = default;
    explicit operator bool() const noexcept {
        return !_STD holds_alternative<monostate>(_Value);
    }
};

template <class _Context, class... _Args>
class _Format_arg_store {
    static constexpr size_t _Num_args       = sizeof...(_Args);
    static constexpr size_t _Num_named_args = (... + _Is_named_arg_v<_Args>);

    // TODO: no arg packing yet

    using _Value_type = basic_format_arg<_Context>;
};

template <class _Context>
class basic_format_args {
public:
    basic_format_args() noexcept;
    template <class... _Args>
    basic_format_args(const _Format_arg_store<_Context, _Args...>& store) noexcept;

    basic_format_arg<_Context> get(size_t _Index) const noexcept;
};

template <class _Out, class _CharT>
class basic_format_context {
private:
    _Out _OutputIt;
    basic_format_args<basic_format_context> _Args;
    _STD locale _Loc;

public:
    using iterator  = _Out;
    using char_type = _CharT;
    template <class _Ty>
    // using formatter_type = formatter<_Ty, _CharT>;
    basic_format_arg<basic_format_context> arg(size_t _Id) const {
        return _Args.get(_Id);
    }
    _STD locale locale() {
        return _Loc;
    }

    iterator out() {
        return _OutputIt;
    }
    void advance_to(iterator _It) {
        // TODO: IDL support probably required
        _OutputIt = _It;
    }
};


// alias declerations
using format_context  = basic_format_context<back_insert_iterator<string>, string::value_type>;
using wformat_context = basic_format_context<back_insert_iterator<wstring>, wstring::value_type>;
using format_args     = basic_format_args<format_context>;
using wformat_args    = basic_format_args<wformat_context>;

// FUNCTION vformat
string vformat(string_view _Fmt, format_args _Args);
wstring vformat(wstring_view _Fmt, wformat_args _Args);
string vformat(const locale& _Loc, string_view _Fmt, format_args _Args);
wstring vformat(const locale& _Loc, wstring_view _Fmt, wformat_args _Args);


_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _HAS_CXX20
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _FORMAT_
